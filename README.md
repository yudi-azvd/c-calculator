<!-- trash -->
# üî¢ Calculadora em C
Esse projeto √© a revitaliza√ß√£o de um antigo trabalho
de Estrutura de Dados para o qual era necess√°rio implementar uma calculadora em C
~~porque quem √© programador de verdade programa em C~~. A calculadora executa algumas
opera√ß√µes b√°sicas utilizando listas lincadas, pilhas e convers√£o entre as formas infixa
e p√≥s-fixa.

Esse projeto faz parte de um "projeto maior" de [calculadoras](https://github.com/yudi-azvd/calculator).

<!-- Esse projeto faz parte do projeto Calculadora(link pro reposit√≥rio principal) -->


## O que ela faz?
Aceita algumas express√µes simples entradas pelo usu√°rio e apresenta o resultado no terminal:

![gif da calculadora](/.github/calculator.gif)


## Depend√™ncias
* git
* gcc
* g++
* [CMake](https://cmake.org/)
* make


## Como usar
Para baixar o reposit√≥rio, abra o terminal e digite:

```
$ git clone https://github.com/y-azvd/c-calculator.git
```

Ou clique no bot√£o verde no diret√≥rio ra√≠z desse reposit√≥rio.

Depois de ter baixado execute no terminal:
```
$ cd c-calculator/build/
$ cmake ..
$ make
```

√â normal demorar um pouco pra compilar porque os testes s√£o realizados utilizando
o framework [Catch2](https://github.com/catchorg/Catch2). Mas √© s√≥ na primeira vez.


Para executar: 
```
$ ./calculator
```

## Documenta√ß√£o

Para saber mais sobre a calculadora, cheque a [documenta√ß√£o](./docs/README.md).

## Extens√µes √∫teis para VSCode

- C/C++
- CMake
- CMake Tools
- C++ TestMate


## A fazer
1. Incluir algumas fun√ß√µes (sin, cos, log).
2. Continuar o testador da `main.c`. Duas formas:
* dois programas rodando em paralelo: `$ ./test_main | ./calculator`
* `input1.txt` com as entradas de comandos e express√µes: `./test_main`, que, por sua vez executaria os seguintes comandos no `TEST_CASES`:
  * `system("./test_main < input1.txt");`
  * `system("./test_main < input2.txt");`
Mas ent√£o como conferir o resultado? Dar uma olhada no trabalho de [EDA2](https://github.com/yudi-azvd/EDA2-Trabalho-2) na parte da intera√ß√£o entre o programa do joagdor e do √°rbitro.

3. Descobrir um jeito melhor de encapsular (e deixar mais leg√≠vel) as fun√ß√µes de receber input e diferenciar os comandos.
